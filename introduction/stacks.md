# Hono Stacks

Hono makes it easy to do the easy things and easy to do the hard things.
It is suitable for creating applications that just only return JSON.
But it's also great for building full-stack REST API servers and the client.

## Basic

Hono's RPC feature allows you to share API specs with little or change to your existing code.
The client generated by `hc` will read the spec and be able to access the endpoint with Type-Safe.

Only the following libraries make this possible, for example.

- Hono - API Server
- [Zod](https://zod.dev) - Validator
- [Zod Validator Middleware](https://github.com/honojs/middleware/tree/main/packages/zod-validator)
- `hc` - HTTP Client

Now let's create an API server and a Client using a Hono Stack.

## Writing API

First, write an endpoint that receives a GET request and returns JSON.

```ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/hello', (c) => {
  return c.json({
    message: `Hello!`,
  })
})
```

## Validate with Zod

Validate with Zod to receive the value of the query parameter.

![SC](/images/sc01.gif)

```ts
import { zValidator } from '@hono/zod-validator'
import { z } from 'zod'

app.get(
  '/hello',
  zValidator(
    'query',
    z.object({
      name: z.string(),
    })
  ),
  (c) => {
    const { name } = c.req.valid('query')
    return c.json({
      message: `Hello! ${name}`,
    })
  }
)
```

## Sharing the Types

To emit an endpoint specification, you turn `json()` into `jsonT()`, get the variable, and export its type.

![SC](/images/sc02.gif)

```ts
const route = app.get(
  '/hello',
  zValidator(
    'query',
    z.object({
      name: z.string(),
    })
  ),
  (c) => {
    const { name } = c.req.valid('query')
    return c.jsonT({
      message: `Hello! ${name}`,
    })
  }
)

export type AppType = typeof route
```

## Client

Next. Client side implementation.
Create a client object by passing the AppType type to `hc` with Generics.
Then, magically, completion works and the endpoint path and request type are suggested.

![SC](/images/sc03.gif)

```ts
import { AppType } from './server'
import { hc } from 'hono/client'

const client = hc<AppType>('/api')
const res = await client.hello.$get({
  query: {
    name: 'Hono',
  },
})
```

The `Response` is compatible with the fetch API, but the data that can be retrieved with `json()` has a type.

![SC](/images/sc04.gif)

```ts
const data = await res.json()
console.log(`${data.message}`)
```

## With React

You can create applications on Cloudflare Pages using React.

The API.

```ts
// functions/api/[[route]].ts
import { Hono } from 'hono'
import { handle } from 'hono/cloudflare-pages'
import { z } from 'zod'
import { zValidator } from '@hono/zod-validator'

const app = new Hono()

const schema = z.object({
  id: z.string(),
  title: z.string(),
})

type Todo = z.infer<typeof schema>

const todos: Todo[] = []

const route = app
  .post('/todo', zValidator('form', schema), (c) => {
    const todo = c.req.valid('form')
    todos.push(todo)
    return c.jsonT({
      message: 'created!',
    })
  })
  .get((c) => {
    return c.jsonT({
      todos,
    })
  })

export type AppType = typeof route

export const onRequest = handle(app, '/api')
```

The Client.

```tsx
// src/App.tsx
import { useQuery, useMutation, QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { AppType } from '../functions/api/[[route]]'
import { hc, InferResponseType, InferRequestType } from 'hono/client'

const queryClient = new QueryClient()
const client = hc<AppType>('/api')

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Todos />
    </QueryClientProvider>
  )
}

const Todos = () => {
  const query = useQuery({
    queryKey: ['todos'],
    queryFn: async () => {
      const res = await client.todo.$get()
      return await res.json()
    },
  })

  const $post = client.todo.$post

  const mutation = useMutation<
    InferResponseType<typeof $post>,
    Error,
    InferRequestType<typeof $post>['form']
  >(
    async (todo) => {
      const res = await $post({
        form: todo,
      })
      return await res.json()
    },
    {
      onSuccess: async () => {
        queryClient.invalidateQueries({ queryKey: ['todos'] })
      },
      onError: (error) => {
        console.log(error)
      },
    }
  )

  return (
    <div>
      <button
        onClick={() => {
          mutation.mutate({
            id: Date.now().toString(),
            title: 'Write code',
          })
        }}
      >
        Add Todo
      </button>

      <ul>
        {query.data?.todos.map((todo) => (
          <li key={todo.id}>{todo.title}</li>
        ))}
      </ul>
    </div>
  )
}
```
